---
title:  "Algorithm 그래프"
excerpt: "그래프 트리"

categories:
  - Algorithm
tags:
  - [Algorithm]

date: 2021-07-22
last_modified_at: 2021-07-22
---

# Graph
> **정점(vertex)**이 **간선(edge)**으로 이어진 형태  
지하철지도, 한붓그리기 그림처럼  
```
 ⑦    ⑧
  \   /
    ① ――― ④ ――― ⑤
  /   \  /        \
 ② ――― ③          ⑥
```
  
그래프를 다르게 구현하는 경우도 있는데, 바로 인접 행렬로 구현하는 방법과 인접 리스트로 구현하는 방법이다  
시간복잡도는 인접행렬 : O(v*e) / 인접 리스트 : O(v+e) 를 가진다
  
## 용어

- 정점(vertex) : 간단하게 말해서, 연결점이다. 좀 더 구체적으로 정의하자면, 여러 가지 특성을 가질 수 있는 객체이다 어떤 객체도 정점이 될 수 있다
  - 고립정점 : 간선이 단 하나도 연결되지 않은 정점

<br/>  
  
- 간선(edge) : 두 정점(vertex)를 연결하는 연결선
  - 단방향 간선 : 단방향으로만 이동가능한 간선(일방통행) / 화살표로 그린다
  - 양방향 간선 : 양방향으로 모두 이동이 가능한 간선 / 양쪽 화살표 또는 그냥 선분으로 그린다
  - 자기 간선 : 자기 자신을 연결하는 간선
  - 다중 간선 : 동일한 다른 접점과 여러 간선이 연결되는 간선
  
<br/>  
  
- 인접(adjacency) : 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접하다
  
<br/>  
  
- 차수(degree) : 정점에 연결된 간선의 수
  - 진입차수(in-degree) : 정점으로 진입하는 간선의 개수
  - 진출차수(out-degree) : 정점에서 진출하는 간선의 개수
  
<br/>  
  
- 경로(path) : 어떤 한 정점에서 다른 하나의 정점으로 가는 길
  - 길이(length) : 어떤 경로에서 시작 정점에서 도착 정점까지 거쳐야 하는 정점의 수
  - 단순 경로 : 경로에서 시작, 끝 정점을 제외한 방문하는 모든 점이 서로 다른 경로
  
<br/>  
  
- 사이클(cycle) : 한 정점에서 진출해서 다시 자기로 돌아올수 있는 경우 사이클이 있다
- 자기루프(self loop) : 한 정점의 간선중 진출하는 간선이 곧바로 자기에게 진입하는 간선이 있을경우 자기루프를 그 정점은 자기루프를 가진다 = **재귀**
  
<br/>  
  
- 단순그래프 : 임의의 두 정점 사이에 간선이 최대 하나 있는 그래프
- 다중그래프 : 임의의 두 정점 사이에 간선이 여러개 있을 수 있는 그래프
- 의사그래프 : 다중 그래프이면서 사이클을 허용하는 그래프
- 무향그래프(undirected graph) : 간선 사이를 왕복 가능 = 양방향 그래프
- 유향그래프(directed graph) : 일방통행만 가능한 그래프 = 단방향 그래프
- 부분 그래프(Sub Graph) : 그래프를 구성하는 정점들을 임의로 선택한 후 그 정점을 연결했던 간선들로 선택한 정점을 연결한 그래프를 말한다
  
<br/>  
<br/>  
  
## 그래프 순회 알고리즘
### 깊이 우선 탐색
> Depth First Search, DFS라고 불리며 이름 그대로, 방문한 정점으로부터 깊게 들어가며 쭉 탐색한 후,  
되돌아 나오다가 아직 탐색하지 않은 노드를 탐색하는 방식을 사용한다.  
<br/>
알고리즘의 실행과정을 설명하면 다음과 같다.  
  
1. 첫 정점을 방문한다.
2. 인접한 정점 중 아직 방문하지 않은 정점을 방문한다(한 길로 쭉 파고 들어간다).
3. 더 이상 들어갈 길이 없을 때(인접한 모든 정점이 이미 방문한 정점일 때), 방문하지 않은 인접한 정점을 찾을 때까지 들어간 길을 돌아나온다.
4. 위 과정을 반복한다.
  
<br/>  
  
### 너비 우선 탐색
> Breadth First Search, BFS라고 불린다. 이름 그대로, 넓게 퍼져가며 정점을 방문한다.  
<br/>
알고리즘의 실행과정은 다음과 같다.  
  
1. 첫 정점을 방문한다.  
2. 아직 방문하지 않은 인접한 정점들을 큐에 넣는다.  
3. 큐에 있는 정점들을 순서대로 방문한다.  
4. 큐에 있는 정점에 대해 인접하면서 아직 방문하지 않은 정점들로 새로운 큐를 구성한다.  
5. 위 과정을 반복한다.  

<br/>  
<br/>  
  
# Tree
> 그래프의 여러 구조 중 무방향 그래프의 한 구조로,  
하나의 뿌리로부터 가지가 사방으로 뻗은 형태가 나무와 닮아 있다고 해서 트리 구조라고 부른다.  
가계도와 흡사한 모양  
<br/>
정점을 **노드**로 간선을 **가지**로 부른다  
<br/>
트리 구조는 **루트(Root)** 라는 하나의 **노드(Node)** (= 정점) 데이터를 시작으로  
여러 개의 데이터를 **간선(edge)**으로 연결  

```
     A  => Root
  ╔══╩══╗
  B     C
╔═╩═╗ ╔═╩═╗
D   E F   G  => leaf Node
```
각 데이터를 노드(**Node**)라고 하며, 두 개의 노드가 상하계층으로 연결되면 부모/자식 관계를 가짐  
위 그림에서 A는 B와 C의 부모 노드(**Parent Node**)이고, D와 E는 B의 자식 노드(**Child Node**)  
자식이 없는 노드는 나무의 잎과 같다고 하여 리프 노드(**leaf Node**)라고 부름
- **Node** : 트리 구조를 이루는 모든 개별 데이터
- **Root** : 트리 구조의 시작점이 되는 노드
- **Parent node** : 두 노드가 상하 관계로 연결되어 있을때 상대적으로 루트에서 가까운 노드
- **Child node** : 두 노드가 상하 관계로 연결되어 있을때 상대적으로 루트에서 먼 노드
- **Leaf** : 트리 구조의 끝 지점이고 , 자식 노드가 없는 노드
  
<br/>  
<br/>  
  
## 용어 설명
```
         A
     ╔═══╩════╗
     B        C
  ╔══╩══╗   ╔═╩═╗
  D     E   F   G
╔═╩═╗ ╔═╩═╗     ╩╗
H   I J   K      L
```
**깊이 (depth)**  
> 트리 구조에서는 루트로부터 하위 계층의 특정 노드까지의 **깊이(depth)**를 표현할 수 있다  
루트 노드는 지면에 있는 것처럼 깊이가 0  
위 그림에서 루트 A의 depth는 0이고, B와 C의 깊이는 1 / D, E, F, G의 깊이는 2 / 나머지는 3

**레벨(Level)**  
> 트리 구조에서 같은 깊이를 가지고 있는 노드를 묶어서 **레벨(level)**로 표현  
depth가 0인 루트 A의 level은 1입니다. depth가 1인 B와 C의 level은 2 / D, E, F, G의 레벨은 3  
같은 레벨에 나란히 있는 노드를 **형제 노드(sibling Node)**라 부른다  

**높이(Height)**  
> 트리 구조에서 리프 노드를 기준으로 루트까지의 **높이(height)**를 표현  
리프 노드와 직간접적으로 연결된 노드의 높이를 표현하며, 부모 노드는 자식 노드의 가장 높은 height 값에 +1한 값을 높이로 가짐  
트리 구조의 높이를 표현할 때에는 각 리프 노드의 높이를 0으로 놓는다  
위 그림에서 H, I, J, K, L의 높이는 0 / D, E, F, G의 높이는 1 / B와 C의 높이는 2  
이때 B는 D의 height + 1 을, C는 G의 height + 1 을 높이로 가진다 따라서, 루트 A의 높이는 3  

**서브 트리(Sub tree)**  
> 트리 구조에서 root에서 뻗어나오는 큰 트리의 내부에, 트리 구조를 갖춘 작은 트리를 서브 트리 라고 부른다  
(D, H, I)로 이루어진 작은 트리도 서브 트리이고, (B, D, E)나 (C, F, G, L)도 서브 트리  
  
<br/>  
<br/>  
  
## 트리 순회 알고리즘
### 전위 순회  
```
     A
  ╔══╩══╗
  B     C
╔═╩═╗ ╔═╩═╗
D   E F   G

결과 : A - B - D - E - C - F - G
```

1. 해당값 확인  
2. 왼쪽확인  
   1. 있을 경우 들어가서 다시 실행
3. 오른쪽확인  
   1. 있을 경우 들어가서 다시 실행
<br/>  
  
### 중위 순회  
```
     A
  ╔══╩══╗
  B     C
╔═╩═╗ ╔═╩═╗
D   E F   G

결과 : D - B - E - A - F - C - G
```

1. 왼쪽확인  
   1. 있을 경우 들어가서 다시 실행
2. 해당값 확인  
3. 오른쪽확인  
   1. 있을 경우 들어가서 다시 실행
<br/>  
  
### 후위 순회
```
     A
  ╔══╩══╗
  B     C
╔═╩═╗ ╔═╩═╗
D   E F   G

결과 : D - E - B - F - G - C - A
```

1. 왼쪽확인  
   1. 있을 경우 들어가서 다시 실행
2. 오른쪽확인  
   1. 있을 경우 들어가서 다시 실행
3. 해당값 확인  
<br/>  
  
### 레벨 순서 순회  
그래프에서의 너비 우선탐색과 같다  

<br/>  
<br/>  
  
### 참조
[리브레위키](https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88)